// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eventmessages/adminBlock.proto

package eventmessages

import (
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ====  ADMIN BLOCK STRUCTURES =====
type AdminBlock struct {
	Header               *AdminBlockHeader  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Entries              []*AdminBlockEntry `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AdminBlock) Reset()         { *m = AdminBlock{} }
func (m *AdminBlock) String() string { return proto.CompactTextString(m) }
func (*AdminBlock) ProtoMessage()    {}
func (*AdminBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{0}
}
func (m *AdminBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminBlock.Merge(m, src)
}
func (m *AdminBlock) XXX_Size() int {
	return m.Size()
}
func (m *AdminBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminBlock.DiscardUnknown(m)
}

var xxx_messageInfo_AdminBlock proto.InternalMessageInfo

func (m *AdminBlock) GetHeader() *AdminBlockHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AdminBlock) GetEntries() []*AdminBlockEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type AdminBlockHeader struct {
	PreviousBackRefHash  *Hash    `protobuf:"bytes,1,opt,name=previousBackRefHash,proto3" json:"previousBackRefHash,omitempty"`
	BlockHeight          uint32   `protobuf:"varint,2,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdminBlockHeader) Reset()         { *m = AdminBlockHeader{} }
func (m *AdminBlockHeader) String() string { return proto.CompactTextString(m) }
func (*AdminBlockHeader) ProtoMessage()    {}
func (*AdminBlockHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{1}
}
func (m *AdminBlockHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminBlockHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminBlockHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminBlockHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminBlockHeader.Merge(m, src)
}
func (m *AdminBlockHeader) XXX_Size() int {
	return m.Size()
}
func (m *AdminBlockHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminBlockHeader.DiscardUnknown(m)
}

var xxx_messageInfo_AdminBlockHeader proto.InternalMessageInfo

func (m *AdminBlockHeader) GetPreviousBackRefHash() *Hash {
	if m != nil {
		return m.PreviousBackRefHash
	}
	return nil
}

func (m *AdminBlockHeader) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

type AdminBlockEntry struct {
	// Types that are valid to be assigned to Value:
	//	*AdminBlockEntry_AddAuditServer
	//	*AdminBlockEntry_AddEfficiency
	//	*AdminBlockEntry_AddFactoidAddress
	//	*AdminBlockEntry_AddFederatedServer
	//	*AdminBlockEntry_AddFederatedServerBitcoinAnchorKey
	//	*AdminBlockEntry_AddFederatedServerSigningKey
	//	*AdminBlockEntry_AddReplaceMatryoshkaHash
	//	*AdminBlockEntry_CancelCoinbaseDescriptor
	//	*AdminBlockEntry_CoinbaseDescriptor
	//	*AdminBlockEntry_DirectoryBlockSignatureEntry
	//	*AdminBlockEntry_EndOfMinuteEntry
	//	*AdminBlockEntry_ForwardCompatibleEntry
	//	*AdminBlockEntry_IncreaseServerCount
	//	*AdminBlockEntry_RemoveFederatedServer
	//	*AdminBlockEntry_RevealMatryoshkaHash
	//	*AdminBlockEntry_ServerFault
	Value                isAdminBlockEntry_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *AdminBlockEntry) Reset()         { *m = AdminBlockEntry{} }
func (m *AdminBlockEntry) String() string { return proto.CompactTextString(m) }
func (*AdminBlockEntry) ProtoMessage()    {}
func (*AdminBlockEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{2}
}
func (m *AdminBlockEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminBlockEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminBlockEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminBlockEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminBlockEntry.Merge(m, src)
}
func (m *AdminBlockEntry) XXX_Size() int {
	return m.Size()
}
func (m *AdminBlockEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminBlockEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AdminBlockEntry proto.InternalMessageInfo

type isAdminBlockEntry_Value interface {
	isAdminBlockEntry_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdminBlockEntry_AddAuditServer struct {
	AddAuditServer *AddAuditServer `protobuf:"bytes,1,opt,name=addAuditServer,proto3,oneof"`
}
type AdminBlockEntry_AddEfficiency struct {
	AddEfficiency *AddEfficiency `protobuf:"bytes,2,opt,name=addEfficiency,proto3,oneof"`
}
type AdminBlockEntry_AddFactoidAddress struct {
	AddFactoidAddress *AddFactoidAddress `protobuf:"bytes,3,opt,name=addFactoidAddress,proto3,oneof"`
}
type AdminBlockEntry_AddFederatedServer struct {
	AddFederatedServer *AddFederatedServer `protobuf:"bytes,4,opt,name=addFederatedServer,proto3,oneof"`
}
type AdminBlockEntry_AddFederatedServerBitcoinAnchorKey struct {
	AddFederatedServerBitcoinAnchorKey *AddFederatedServerBitcoinAnchorKey `protobuf:"bytes,5,opt,name=addFederatedServerBitcoinAnchorKey,proto3,oneof"`
}
type AdminBlockEntry_AddFederatedServerSigningKey struct {
	AddFederatedServerSigningKey *AddFederatedServerSigningKey `protobuf:"bytes,6,opt,name=addFederatedServerSigningKey,proto3,oneof"`
}
type AdminBlockEntry_AddReplaceMatryoshkaHash struct {
	AddReplaceMatryoshkaHash *AddReplaceMatryoshkaHash `protobuf:"bytes,7,opt,name=addReplaceMatryoshkaHash,proto3,oneof"`
}
type AdminBlockEntry_CancelCoinbaseDescriptor struct {
	CancelCoinbaseDescriptor *CancelCoinbaseDescriptor `protobuf:"bytes,8,opt,name=cancelCoinbaseDescriptor,proto3,oneof"`
}
type AdminBlockEntry_CoinbaseDescriptor struct {
	CoinbaseDescriptor *CoinbaseDescriptor `protobuf:"bytes,9,opt,name=coinbaseDescriptor,proto3,oneof"`
}
type AdminBlockEntry_DirectoryBlockSignatureEntry struct {
	DirectoryBlockSignatureEntry *DirectoryBlockSignatureEntry `protobuf:"bytes,10,opt,name=directoryBlockSignatureEntry,proto3,oneof"`
}
type AdminBlockEntry_EndOfMinuteEntry struct {
	EndOfMinuteEntry *EndOfMinuteEntry `protobuf:"bytes,11,opt,name=endOfMinuteEntry,proto3,oneof"`
}
type AdminBlockEntry_ForwardCompatibleEntry struct {
	ForwardCompatibleEntry *ForwardCompatibleEntry `protobuf:"bytes,12,opt,name=forwardCompatibleEntry,proto3,oneof"`
}
type AdminBlockEntry_IncreaseServerCount struct {
	IncreaseServerCount *IncreaseServerCount `protobuf:"bytes,13,opt,name=increaseServerCount,proto3,oneof"`
}
type AdminBlockEntry_RemoveFederatedServer struct {
	RemoveFederatedServer *RemoveFederatedServer `protobuf:"bytes,14,opt,name=removeFederatedServer,proto3,oneof"`
}
type AdminBlockEntry_RevealMatryoshkaHash struct {
	RevealMatryoshkaHash *RevealMatryoshkaHash `protobuf:"bytes,15,opt,name=revealMatryoshkaHash,proto3,oneof"`
}
type AdminBlockEntry_ServerFault struct {
	ServerFault *ServerFault `protobuf:"bytes,16,opt,name=serverFault,proto3,oneof"`
}

func (*AdminBlockEntry_AddAuditServer) isAdminBlockEntry_Value()                     {}
func (*AdminBlockEntry_AddEfficiency) isAdminBlockEntry_Value()                      {}
func (*AdminBlockEntry_AddFactoidAddress) isAdminBlockEntry_Value()                  {}
func (*AdminBlockEntry_AddFederatedServer) isAdminBlockEntry_Value()                 {}
func (*AdminBlockEntry_AddFederatedServerBitcoinAnchorKey) isAdminBlockEntry_Value() {}
func (*AdminBlockEntry_AddFederatedServerSigningKey) isAdminBlockEntry_Value()       {}
func (*AdminBlockEntry_AddReplaceMatryoshkaHash) isAdminBlockEntry_Value()           {}
func (*AdminBlockEntry_CancelCoinbaseDescriptor) isAdminBlockEntry_Value()           {}
func (*AdminBlockEntry_CoinbaseDescriptor) isAdminBlockEntry_Value()                 {}
func (*AdminBlockEntry_DirectoryBlockSignatureEntry) isAdminBlockEntry_Value()       {}
func (*AdminBlockEntry_EndOfMinuteEntry) isAdminBlockEntry_Value()                   {}
func (*AdminBlockEntry_ForwardCompatibleEntry) isAdminBlockEntry_Value()             {}
func (*AdminBlockEntry_IncreaseServerCount) isAdminBlockEntry_Value()                {}
func (*AdminBlockEntry_RemoveFederatedServer) isAdminBlockEntry_Value()              {}
func (*AdminBlockEntry_RevealMatryoshkaHash) isAdminBlockEntry_Value()               {}
func (*AdminBlockEntry_ServerFault) isAdminBlockEntry_Value()                        {}

func (m *AdminBlockEntry) GetValue() isAdminBlockEntry_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AdminBlockEntry) GetAddAuditServer() *AddAuditServer {
	if x, ok := m.GetValue().(*AdminBlockEntry_AddAuditServer); ok {
		return x.AddAuditServer
	}
	return nil
}

func (m *AdminBlockEntry) GetAddEfficiency() *AddEfficiency {
	if x, ok := m.GetValue().(*AdminBlockEntry_AddEfficiency); ok {
		return x.AddEfficiency
	}
	return nil
}

func (m *AdminBlockEntry) GetAddFactoidAddress() *AddFactoidAddress {
	if x, ok := m.GetValue().(*AdminBlockEntry_AddFactoidAddress); ok {
		return x.AddFactoidAddress
	}
	return nil
}

func (m *AdminBlockEntry) GetAddFederatedServer() *AddFederatedServer {
	if x, ok := m.GetValue().(*AdminBlockEntry_AddFederatedServer); ok {
		return x.AddFederatedServer
	}
	return nil
}

func (m *AdminBlockEntry) GetAddFederatedServerBitcoinAnchorKey() *AddFederatedServerBitcoinAnchorKey {
	if x, ok := m.GetValue().(*AdminBlockEntry_AddFederatedServerBitcoinAnchorKey); ok {
		return x.AddFederatedServerBitcoinAnchorKey
	}
	return nil
}

func (m *AdminBlockEntry) GetAddFederatedServerSigningKey() *AddFederatedServerSigningKey {
	if x, ok := m.GetValue().(*AdminBlockEntry_AddFederatedServerSigningKey); ok {
		return x.AddFederatedServerSigningKey
	}
	return nil
}

func (m *AdminBlockEntry) GetAddReplaceMatryoshkaHash() *AddReplaceMatryoshkaHash {
	if x, ok := m.GetValue().(*AdminBlockEntry_AddReplaceMatryoshkaHash); ok {
		return x.AddReplaceMatryoshkaHash
	}
	return nil
}

func (m *AdminBlockEntry) GetCancelCoinbaseDescriptor() *CancelCoinbaseDescriptor {
	if x, ok := m.GetValue().(*AdminBlockEntry_CancelCoinbaseDescriptor); ok {
		return x.CancelCoinbaseDescriptor
	}
	return nil
}

func (m *AdminBlockEntry) GetCoinbaseDescriptor() *CoinbaseDescriptor {
	if x, ok := m.GetValue().(*AdminBlockEntry_CoinbaseDescriptor); ok {
		return x.CoinbaseDescriptor
	}
	return nil
}

func (m *AdminBlockEntry) GetDirectoryBlockSignatureEntry() *DirectoryBlockSignatureEntry {
	if x, ok := m.GetValue().(*AdminBlockEntry_DirectoryBlockSignatureEntry); ok {
		return x.DirectoryBlockSignatureEntry
	}
	return nil
}

func (m *AdminBlockEntry) GetEndOfMinuteEntry() *EndOfMinuteEntry {
	if x, ok := m.GetValue().(*AdminBlockEntry_EndOfMinuteEntry); ok {
		return x.EndOfMinuteEntry
	}
	return nil
}

func (m *AdminBlockEntry) GetForwardCompatibleEntry() *ForwardCompatibleEntry {
	if x, ok := m.GetValue().(*AdminBlockEntry_ForwardCompatibleEntry); ok {
		return x.ForwardCompatibleEntry
	}
	return nil
}

func (m *AdminBlockEntry) GetIncreaseServerCount() *IncreaseServerCount {
	if x, ok := m.GetValue().(*AdminBlockEntry_IncreaseServerCount); ok {
		return x.IncreaseServerCount
	}
	return nil
}

func (m *AdminBlockEntry) GetRemoveFederatedServer() *RemoveFederatedServer {
	if x, ok := m.GetValue().(*AdminBlockEntry_RemoveFederatedServer); ok {
		return x.RemoveFederatedServer
	}
	return nil
}

func (m *AdminBlockEntry) GetRevealMatryoshkaHash() *RevealMatryoshkaHash {
	if x, ok := m.GetValue().(*AdminBlockEntry_RevealMatryoshkaHash); ok {
		return x.RevealMatryoshkaHash
	}
	return nil
}

func (m *AdminBlockEntry) GetServerFault() *ServerFault {
	if x, ok := m.GetValue().(*AdminBlockEntry_ServerFault); ok {
		return x.ServerFault
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AdminBlockEntry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AdminBlockEntry_OneofMarshaler, _AdminBlockEntry_OneofUnmarshaler, _AdminBlockEntry_OneofSizer, []interface{}{
		(*AdminBlockEntry_AddAuditServer)(nil),
		(*AdminBlockEntry_AddEfficiency)(nil),
		(*AdminBlockEntry_AddFactoidAddress)(nil),
		(*AdminBlockEntry_AddFederatedServer)(nil),
		(*AdminBlockEntry_AddFederatedServerBitcoinAnchorKey)(nil),
		(*AdminBlockEntry_AddFederatedServerSigningKey)(nil),
		(*AdminBlockEntry_AddReplaceMatryoshkaHash)(nil),
		(*AdminBlockEntry_CancelCoinbaseDescriptor)(nil),
		(*AdminBlockEntry_CoinbaseDescriptor)(nil),
		(*AdminBlockEntry_DirectoryBlockSignatureEntry)(nil),
		(*AdminBlockEntry_EndOfMinuteEntry)(nil),
		(*AdminBlockEntry_ForwardCompatibleEntry)(nil),
		(*AdminBlockEntry_IncreaseServerCount)(nil),
		(*AdminBlockEntry_RemoveFederatedServer)(nil),
		(*AdminBlockEntry_RevealMatryoshkaHash)(nil),
		(*AdminBlockEntry_ServerFault)(nil),
	}
}

func _AdminBlockEntry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AdminBlockEntry)
	// value
	switch x := m.Value.(type) {
	case *AdminBlockEntry_AddAuditServer:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddAuditServer); err != nil {
			return err
		}
	case *AdminBlockEntry_AddEfficiency:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddEfficiency); err != nil {
			return err
		}
	case *AdminBlockEntry_AddFactoidAddress:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddFactoidAddress); err != nil {
			return err
		}
	case *AdminBlockEntry_AddFederatedServer:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddFederatedServer); err != nil {
			return err
		}
	case *AdminBlockEntry_AddFederatedServerBitcoinAnchorKey:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddFederatedServerBitcoinAnchorKey); err != nil {
			return err
		}
	case *AdminBlockEntry_AddFederatedServerSigningKey:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddFederatedServerSigningKey); err != nil {
			return err
		}
	case *AdminBlockEntry_AddReplaceMatryoshkaHash:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddReplaceMatryoshkaHash); err != nil {
			return err
		}
	case *AdminBlockEntry_CancelCoinbaseDescriptor:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CancelCoinbaseDescriptor); err != nil {
			return err
		}
	case *AdminBlockEntry_CoinbaseDescriptor:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CoinbaseDescriptor); err != nil {
			return err
		}
	case *AdminBlockEntry_DirectoryBlockSignatureEntry:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DirectoryBlockSignatureEntry); err != nil {
			return err
		}
	case *AdminBlockEntry_EndOfMinuteEntry:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EndOfMinuteEntry); err != nil {
			return err
		}
	case *AdminBlockEntry_ForwardCompatibleEntry:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ForwardCompatibleEntry); err != nil {
			return err
		}
	case *AdminBlockEntry_IncreaseServerCount:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IncreaseServerCount); err != nil {
			return err
		}
	case *AdminBlockEntry_RemoveFederatedServer:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemoveFederatedServer); err != nil {
			return err
		}
	case *AdminBlockEntry_RevealMatryoshkaHash:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RevealMatryoshkaHash); err != nil {
			return err
		}
	case *AdminBlockEntry_ServerFault:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerFault); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AdminBlockEntry.Value has unexpected type %T", x)
	}
	return nil
}

func _AdminBlockEntry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AdminBlockEntry)
	switch tag {
	case 1: // value.addAuditServer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddAuditServer)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_AddAuditServer{msg}
		return true, err
	case 2: // value.addEfficiency
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddEfficiency)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_AddEfficiency{msg}
		return true, err
	case 3: // value.addFactoidAddress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddFactoidAddress)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_AddFactoidAddress{msg}
		return true, err
	case 4: // value.addFederatedServer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddFederatedServer)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_AddFederatedServer{msg}
		return true, err
	case 5: // value.addFederatedServerBitcoinAnchorKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddFederatedServerBitcoinAnchorKey)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_AddFederatedServerBitcoinAnchorKey{msg}
		return true, err
	case 6: // value.addFederatedServerSigningKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddFederatedServerSigningKey)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_AddFederatedServerSigningKey{msg}
		return true, err
	case 7: // value.addReplaceMatryoshkaHash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddReplaceMatryoshkaHash)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_AddReplaceMatryoshkaHash{msg}
		return true, err
	case 8: // value.cancelCoinbaseDescriptor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CancelCoinbaseDescriptor)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_CancelCoinbaseDescriptor{msg}
		return true, err
	case 9: // value.coinbaseDescriptor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CoinbaseDescriptor)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_CoinbaseDescriptor{msg}
		return true, err
	case 10: // value.directoryBlockSignatureEntry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DirectoryBlockSignatureEntry)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_DirectoryBlockSignatureEntry{msg}
		return true, err
	case 11: // value.endOfMinuteEntry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndOfMinuteEntry)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_EndOfMinuteEntry{msg}
		return true, err
	case 12: // value.forwardCompatibleEntry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ForwardCompatibleEntry)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_ForwardCompatibleEntry{msg}
		return true, err
	case 13: // value.increaseServerCount
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IncreaseServerCount)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_IncreaseServerCount{msg}
		return true, err
	case 14: // value.removeFederatedServer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RemoveFederatedServer)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_RemoveFederatedServer{msg}
		return true, err
	case 15: // value.revealMatryoshkaHash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RevealMatryoshkaHash)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_RevealMatryoshkaHash{msg}
		return true, err
	case 16: // value.serverFault
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerFault)
		err := b.DecodeMessage(msg)
		m.Value = &AdminBlockEntry_ServerFault{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AdminBlockEntry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AdminBlockEntry)
	// value
	switch x := m.Value.(type) {
	case *AdminBlockEntry_AddAuditServer:
		s := proto.Size(x.AddAuditServer)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_AddEfficiency:
		s := proto.Size(x.AddEfficiency)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_AddFactoidAddress:
		s := proto.Size(x.AddFactoidAddress)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_AddFederatedServer:
		s := proto.Size(x.AddFederatedServer)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_AddFederatedServerBitcoinAnchorKey:
		s := proto.Size(x.AddFederatedServerBitcoinAnchorKey)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_AddFederatedServerSigningKey:
		s := proto.Size(x.AddFederatedServerSigningKey)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_AddReplaceMatryoshkaHash:
		s := proto.Size(x.AddReplaceMatryoshkaHash)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_CancelCoinbaseDescriptor:
		s := proto.Size(x.CancelCoinbaseDescriptor)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_CoinbaseDescriptor:
		s := proto.Size(x.CoinbaseDescriptor)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_DirectoryBlockSignatureEntry:
		s := proto.Size(x.DirectoryBlockSignatureEntry)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_EndOfMinuteEntry:
		s := proto.Size(x.EndOfMinuteEntry)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_ForwardCompatibleEntry:
		s := proto.Size(x.ForwardCompatibleEntry)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_IncreaseServerCount:
		s := proto.Size(x.IncreaseServerCount)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_RemoveFederatedServer:
		s := proto.Size(x.RemoveFederatedServer)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_RevealMatryoshkaHash:
		s := proto.Size(x.RevealMatryoshkaHash)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AdminBlockEntry_ServerFault:
		s := proto.Size(x.ServerFault)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AddAuditServer struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	BlockHeight          uint32   `protobuf:"varint,2,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddAuditServer) Reset()         { *m = AddAuditServer{} }
func (m *AddAuditServer) String() string { return proto.CompactTextString(m) }
func (*AddAuditServer) ProtoMessage()    {}
func (*AddAuditServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{3}
}
func (m *AddAuditServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddAuditServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddAuditServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddAuditServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddAuditServer.Merge(m, src)
}
func (m *AddAuditServer) XXX_Size() int {
	return m.Size()
}
func (m *AddAuditServer) XXX_DiscardUnknown() {
	xxx_messageInfo_AddAuditServer.DiscardUnknown(m)
}

var xxx_messageInfo_AddAuditServer proto.InternalMessageInfo

func (m *AddAuditServer) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *AddAuditServer) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

type AddEfficiency struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	Efficiency           uint32   `protobuf:"varint,2,opt,name=efficiency,proto3" json:"efficiency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddEfficiency) Reset()         { *m = AddEfficiency{} }
func (m *AddEfficiency) String() string { return proto.CompactTextString(m) }
func (*AddEfficiency) ProtoMessage()    {}
func (*AddEfficiency) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{4}
}
func (m *AddEfficiency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddEfficiency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddEfficiency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddEfficiency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddEfficiency.Merge(m, src)
}
func (m *AddEfficiency) XXX_Size() int {
	return m.Size()
}
func (m *AddEfficiency) XXX_DiscardUnknown() {
	xxx_messageInfo_AddEfficiency.DiscardUnknown(m)
}

var xxx_messageInfo_AddEfficiency proto.InternalMessageInfo

func (m *AddEfficiency) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *AddEfficiency) GetEfficiency() uint32 {
	if m != nil {
		return m.Efficiency
	}
	return 0
}

type AddFactoidAddress struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	Address              *Hash    `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddFactoidAddress) Reset()         { *m = AddFactoidAddress{} }
func (m *AddFactoidAddress) String() string { return proto.CompactTextString(m) }
func (*AddFactoidAddress) ProtoMessage()    {}
func (*AddFactoidAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{5}
}
func (m *AddFactoidAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFactoidAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFactoidAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFactoidAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFactoidAddress.Merge(m, src)
}
func (m *AddFactoidAddress) XXX_Size() int {
	return m.Size()
}
func (m *AddFactoidAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFactoidAddress.DiscardUnknown(m)
}

var xxx_messageInfo_AddFactoidAddress proto.InternalMessageInfo

func (m *AddFactoidAddress) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *AddFactoidAddress) GetAddress() *Hash {
	if m != nil {
		return m.Address
	}
	return nil
}

type AddFederatedServer struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	BlockHeight          uint32   `protobuf:"varint,2,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddFederatedServer) Reset()         { *m = AddFederatedServer{} }
func (m *AddFederatedServer) String() string { return proto.CompactTextString(m) }
func (*AddFederatedServer) ProtoMessage()    {}
func (*AddFederatedServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{6}
}
func (m *AddFederatedServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFederatedServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFederatedServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFederatedServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFederatedServer.Merge(m, src)
}
func (m *AddFederatedServer) XXX_Size() int {
	return m.Size()
}
func (m *AddFederatedServer) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFederatedServer.DiscardUnknown(m)
}

var xxx_messageInfo_AddFederatedServer proto.InternalMessageInfo

func (m *AddFederatedServer) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *AddFederatedServer) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

type AddFederatedServerBitcoinAnchorKey struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	KeyPriority          uint32   `protobuf:"varint,2,opt,name=keyPriority,proto3" json:"keyPriority,omitempty"`
	KeyType              uint32   `protobuf:"varint,3,opt,name=keyType,proto3" json:"keyType,omitempty"`
	EcdsaPublicKey       []byte   `protobuf:"bytes,4,opt,name=ecdsaPublicKey,proto3" json:"ecdsaPublicKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddFederatedServerBitcoinAnchorKey) Reset()         { *m = AddFederatedServerBitcoinAnchorKey{} }
func (m *AddFederatedServerBitcoinAnchorKey) String() string { return proto.CompactTextString(m) }
func (*AddFederatedServerBitcoinAnchorKey) ProtoMessage()    {}
func (*AddFederatedServerBitcoinAnchorKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{7}
}
func (m *AddFederatedServerBitcoinAnchorKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFederatedServerBitcoinAnchorKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFederatedServerBitcoinAnchorKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFederatedServerBitcoinAnchorKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFederatedServerBitcoinAnchorKey.Merge(m, src)
}
func (m *AddFederatedServerBitcoinAnchorKey) XXX_Size() int {
	return m.Size()
}
func (m *AddFederatedServerBitcoinAnchorKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFederatedServerBitcoinAnchorKey.DiscardUnknown(m)
}

var xxx_messageInfo_AddFederatedServerBitcoinAnchorKey proto.InternalMessageInfo

func (m *AddFederatedServerBitcoinAnchorKey) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *AddFederatedServerBitcoinAnchorKey) GetKeyPriority() uint32 {
	if m != nil {
		return m.KeyPriority
	}
	return 0
}

func (m *AddFederatedServerBitcoinAnchorKey) GetKeyType() uint32 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

func (m *AddFederatedServerBitcoinAnchorKey) GetEcdsaPublicKey() []byte {
	if m != nil {
		return m.EcdsaPublicKey
	}
	return nil
}

type AddFederatedServerSigningKey struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	KeyPriority          uint32   `protobuf:"varint,2,opt,name=keyPriority,proto3" json:"keyPriority,omitempty"`
	PublicKey            []byte   `protobuf:"bytes,3,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
	BlockHeight          uint32   `protobuf:"varint,4,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddFederatedServerSigningKey) Reset()         { *m = AddFederatedServerSigningKey{} }
func (m *AddFederatedServerSigningKey) String() string { return proto.CompactTextString(m) }
func (*AddFederatedServerSigningKey) ProtoMessage()    {}
func (*AddFederatedServerSigningKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{8}
}
func (m *AddFederatedServerSigningKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFederatedServerSigningKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFederatedServerSigningKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFederatedServerSigningKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFederatedServerSigningKey.Merge(m, src)
}
func (m *AddFederatedServerSigningKey) XXX_Size() int {
	return m.Size()
}
func (m *AddFederatedServerSigningKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFederatedServerSigningKey.DiscardUnknown(m)
}

var xxx_messageInfo_AddFederatedServerSigningKey proto.InternalMessageInfo

func (m *AddFederatedServerSigningKey) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *AddFederatedServerSigningKey) GetKeyPriority() uint32 {
	if m != nil {
		return m.KeyPriority
	}
	return 0
}

func (m *AddFederatedServerSigningKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *AddFederatedServerSigningKey) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

type AddReplaceMatryoshkaHash struct {
	IdentityChainID      *Hash                 `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	MatryoshkaHash       *Hash                 `protobuf:"bytes,2,opt,name=matryoshkaHash,proto3" json:"matryoshkaHash,omitempty"`
	FactoidOutputs       []*TransactionAddress `protobuf:"bytes,3,rep,name=factoidOutputs,proto3" json:"factoidOutputs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *AddReplaceMatryoshkaHash) Reset()         { *m = AddReplaceMatryoshkaHash{} }
func (m *AddReplaceMatryoshkaHash) String() string { return proto.CompactTextString(m) }
func (*AddReplaceMatryoshkaHash) ProtoMessage()    {}
func (*AddReplaceMatryoshkaHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{9}
}
func (m *AddReplaceMatryoshkaHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddReplaceMatryoshkaHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddReplaceMatryoshkaHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddReplaceMatryoshkaHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddReplaceMatryoshkaHash.Merge(m, src)
}
func (m *AddReplaceMatryoshkaHash) XXX_Size() int {
	return m.Size()
}
func (m *AddReplaceMatryoshkaHash) XXX_DiscardUnknown() {
	xxx_messageInfo_AddReplaceMatryoshkaHash.DiscardUnknown(m)
}

var xxx_messageInfo_AddReplaceMatryoshkaHash proto.InternalMessageInfo

func (m *AddReplaceMatryoshkaHash) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *AddReplaceMatryoshkaHash) GetMatryoshkaHash() *Hash {
	if m != nil {
		return m.MatryoshkaHash
	}
	return nil
}

func (m *AddReplaceMatryoshkaHash) GetFactoidOutputs() []*TransactionAddress {
	if m != nil {
		return m.FactoidOutputs
	}
	return nil
}

type CancelCoinbaseDescriptor struct {
	DescriptorHeight     uint32   `protobuf:"varint,1,opt,name=descriptorHeight,proto3" json:"descriptorHeight,omitempty"`
	DescriptorIndex      uint32   `protobuf:"varint,2,opt,name=descriptorIndex,proto3" json:"descriptorIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelCoinbaseDescriptor) Reset()         { *m = CancelCoinbaseDescriptor{} }
func (m *CancelCoinbaseDescriptor) String() string { return proto.CompactTextString(m) }
func (*CancelCoinbaseDescriptor) ProtoMessage()    {}
func (*CancelCoinbaseDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{10}
}
func (m *CancelCoinbaseDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelCoinbaseDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelCoinbaseDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelCoinbaseDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelCoinbaseDescriptor.Merge(m, src)
}
func (m *CancelCoinbaseDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *CancelCoinbaseDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelCoinbaseDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CancelCoinbaseDescriptor proto.InternalMessageInfo

func (m *CancelCoinbaseDescriptor) GetDescriptorHeight() uint32 {
	if m != nil {
		return m.DescriptorHeight
	}
	return 0
}

func (m *CancelCoinbaseDescriptor) GetDescriptorIndex() uint32 {
	if m != nil {
		return m.DescriptorIndex
	}
	return 0
}

type CoinbaseDescriptor struct {
	FactoidOutputs       []*TransactionAddress `protobuf:"bytes,1,rep,name=factoidOutputs,proto3" json:"factoidOutputs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CoinbaseDescriptor) Reset()         { *m = CoinbaseDescriptor{} }
func (m *CoinbaseDescriptor) String() string { return proto.CompactTextString(m) }
func (*CoinbaseDescriptor) ProtoMessage()    {}
func (*CoinbaseDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{11}
}
func (m *CoinbaseDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinbaseDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinbaseDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinbaseDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinbaseDescriptor.Merge(m, src)
}
func (m *CoinbaseDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *CoinbaseDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinbaseDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CoinbaseDescriptor proto.InternalMessageInfo

func (m *CoinbaseDescriptor) GetFactoidOutputs() []*TransactionAddress {
	if m != nil {
		return m.FactoidOutputs
	}
	return nil
}

type DirectoryBlockSignatureEntry struct {
	IdentityAdminChainID            *Hash      `protobuf:"bytes,1,opt,name=identityAdminChainID,proto3" json:"identityAdminChainID,omitempty"`
	PreviousDirectoryBlockSignature *Signature `protobuf:"bytes,2,opt,name=previousDirectoryBlockSignature,proto3" json:"previousDirectoryBlockSignature,omitempty"`
	XXX_NoUnkeyedLiteral            struct{}   `json:"-"`
	XXX_unrecognized                []byte     `json:"-"`
	XXX_sizecache                   int32      `json:"-"`
}

func (m *DirectoryBlockSignatureEntry) Reset()         { *m = DirectoryBlockSignatureEntry{} }
func (m *DirectoryBlockSignatureEntry) String() string { return proto.CompactTextString(m) }
func (*DirectoryBlockSignatureEntry) ProtoMessage()    {}
func (*DirectoryBlockSignatureEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{12}
}
func (m *DirectoryBlockSignatureEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectoryBlockSignatureEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectoryBlockSignatureEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectoryBlockSignatureEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectoryBlockSignatureEntry.Merge(m, src)
}
func (m *DirectoryBlockSignatureEntry) XXX_Size() int {
	return m.Size()
}
func (m *DirectoryBlockSignatureEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectoryBlockSignatureEntry.DiscardUnknown(m)
}

var xxx_messageInfo_DirectoryBlockSignatureEntry proto.InternalMessageInfo

func (m *DirectoryBlockSignatureEntry) GetIdentityAdminChainID() *Hash {
	if m != nil {
		return m.IdentityAdminChainID
	}
	return nil
}

func (m *DirectoryBlockSignatureEntry) GetPreviousDirectoryBlockSignature() *Signature {
	if m != nil {
		return m.PreviousDirectoryBlockSignature
	}
	return nil
}

type EndOfMinuteEntry struct {
	MinuteNumber         uint32   `protobuf:"varint,1,opt,name=minuteNumber,proto3" json:"minuteNumber,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EndOfMinuteEntry) Reset()         { *m = EndOfMinuteEntry{} }
func (m *EndOfMinuteEntry) String() string { return proto.CompactTextString(m) }
func (*EndOfMinuteEntry) ProtoMessage()    {}
func (*EndOfMinuteEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{13}
}
func (m *EndOfMinuteEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndOfMinuteEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndOfMinuteEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndOfMinuteEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndOfMinuteEntry.Merge(m, src)
}
func (m *EndOfMinuteEntry) XXX_Size() int {
	return m.Size()
}
func (m *EndOfMinuteEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_EndOfMinuteEntry.DiscardUnknown(m)
}

var xxx_messageInfo_EndOfMinuteEntry proto.InternalMessageInfo

func (m *EndOfMinuteEntry) GetMinuteNumber() uint32 {
	if m != nil {
		return m.MinuteNumber
	}
	return 0
}

type ForwardCompatibleEntry struct {
	Size_                uint32   `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForwardCompatibleEntry) Reset()         { *m = ForwardCompatibleEntry{} }
func (m *ForwardCompatibleEntry) String() string { return proto.CompactTextString(m) }
func (*ForwardCompatibleEntry) ProtoMessage()    {}
func (*ForwardCompatibleEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{14}
}
func (m *ForwardCompatibleEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardCompatibleEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardCompatibleEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardCompatibleEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardCompatibleEntry.Merge(m, src)
}
func (m *ForwardCompatibleEntry) XXX_Size() int {
	return m.Size()
}
func (m *ForwardCompatibleEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardCompatibleEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardCompatibleEntry proto.InternalMessageInfo

func (m *ForwardCompatibleEntry) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ForwardCompatibleEntry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type IncreaseServerCount struct {
	Amount               uint32   `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IncreaseServerCount) Reset()         { *m = IncreaseServerCount{} }
func (m *IncreaseServerCount) String() string { return proto.CompactTextString(m) }
func (*IncreaseServerCount) ProtoMessage()    {}
func (*IncreaseServerCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{15}
}
func (m *IncreaseServerCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncreaseServerCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncreaseServerCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncreaseServerCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncreaseServerCount.Merge(m, src)
}
func (m *IncreaseServerCount) XXX_Size() int {
	return m.Size()
}
func (m *IncreaseServerCount) XXX_DiscardUnknown() {
	xxx_messageInfo_IncreaseServerCount.DiscardUnknown(m)
}

var xxx_messageInfo_IncreaseServerCount proto.InternalMessageInfo

func (m *IncreaseServerCount) GetAmount() uint32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type RemoveFederatedServer struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	BlockHeight          uint32   `protobuf:"varint,2,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveFederatedServer) Reset()         { *m = RemoveFederatedServer{} }
func (m *RemoveFederatedServer) String() string { return proto.CompactTextString(m) }
func (*RemoveFederatedServer) ProtoMessage()    {}
func (*RemoveFederatedServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{16}
}
func (m *RemoveFederatedServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveFederatedServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveFederatedServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveFederatedServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveFederatedServer.Merge(m, src)
}
func (m *RemoveFederatedServer) XXX_Size() int {
	return m.Size()
}
func (m *RemoveFederatedServer) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveFederatedServer.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveFederatedServer proto.InternalMessageInfo

func (m *RemoveFederatedServer) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *RemoveFederatedServer) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

type RevealMatryoshkaHash struct {
	IdentityChainID      *Hash    `protobuf:"bytes,1,opt,name=identityChainID,proto3" json:"identityChainID,omitempty"`
	MatryoshkaHash       *Hash    `protobuf:"bytes,2,opt,name=matryoshkaHash,proto3" json:"matryoshkaHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RevealMatryoshkaHash) Reset()         { *m = RevealMatryoshkaHash{} }
func (m *RevealMatryoshkaHash) String() string { return proto.CompactTextString(m) }
func (*RevealMatryoshkaHash) ProtoMessage()    {}
func (*RevealMatryoshkaHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{17}
}
func (m *RevealMatryoshkaHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevealMatryoshkaHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevealMatryoshkaHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RevealMatryoshkaHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevealMatryoshkaHash.Merge(m, src)
}
func (m *RevealMatryoshkaHash) XXX_Size() int {
	return m.Size()
}
func (m *RevealMatryoshkaHash) XXX_DiscardUnknown() {
	xxx_messageInfo_RevealMatryoshkaHash.DiscardUnknown(m)
}

var xxx_messageInfo_RevealMatryoshkaHash proto.InternalMessageInfo

func (m *RevealMatryoshkaHash) GetIdentityChainID() *Hash {
	if m != nil {
		return m.IdentityChainID
	}
	return nil
}

func (m *RevealMatryoshkaHash) GetMatryoshkaHash() *Hash {
	if m != nil {
		return m.MatryoshkaHash
	}
	return nil
}

type ServerFault struct {
	Timestamp            *types.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ServerID             *Hash            `protobuf:"bytes,2,opt,name=serverID,proto3" json:"serverID,omitempty"`
	AuditServerID        *Hash            `protobuf:"bytes,3,opt,name=auditServerID,proto3" json:"auditServerID,omitempty"`
	VmIndex              uint32           `protobuf:"varint,4,opt,name=vmIndex,proto3" json:"vmIndex,omitempty"`
	BlockHeight          uint32           `protobuf:"varint,5,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	MessageEntryHeight   uint32           `protobuf:"varint,6,opt,name=messageEntryHeight,proto3" json:"messageEntryHeight,omitempty"`
	SignatureList        []*Signature     `protobuf:"bytes,7,rep,name=signatureList,proto3" json:"signatureList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ServerFault) Reset()         { *m = ServerFault{} }
func (m *ServerFault) String() string { return proto.CompactTextString(m) }
func (*ServerFault) ProtoMessage()    {}
func (*ServerFault) Descriptor() ([]byte, []int) {
	return fileDescriptor_974412be9cb81647, []int{18}
}
func (m *ServerFault) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerFault) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerFault.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerFault) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerFault.Merge(m, src)
}
func (m *ServerFault) XXX_Size() int {
	return m.Size()
}
func (m *ServerFault) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerFault.DiscardUnknown(m)
}

var xxx_messageInfo_ServerFault proto.InternalMessageInfo

func (m *ServerFault) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *ServerFault) GetServerID() *Hash {
	if m != nil {
		return m.ServerID
	}
	return nil
}

func (m *ServerFault) GetAuditServerID() *Hash {
	if m != nil {
		return m.AuditServerID
	}
	return nil
}

func (m *ServerFault) GetVmIndex() uint32 {
	if m != nil {
		return m.VmIndex
	}
	return 0
}

func (m *ServerFault) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ServerFault) GetMessageEntryHeight() uint32 {
	if m != nil {
		return m.MessageEntryHeight
	}
	return 0
}

func (m *ServerFault) GetSignatureList() []*Signature {
	if m != nil {
		return m.SignatureList
	}
	return nil
}

func init() {
	proto.RegisterType((*AdminBlock)(nil), "eventmessages.AdminBlock")
	proto.RegisterType((*AdminBlockHeader)(nil), "eventmessages.AdminBlockHeader")
	proto.RegisterType((*AdminBlockEntry)(nil), "eventmessages.AdminBlockEntry")
	proto.RegisterType((*AddAuditServer)(nil), "eventmessages.AddAuditServer")
	proto.RegisterType((*AddEfficiency)(nil), "eventmessages.AddEfficiency")
	proto.RegisterType((*AddFactoidAddress)(nil), "eventmessages.AddFactoidAddress")
	proto.RegisterType((*AddFederatedServer)(nil), "eventmessages.AddFederatedServer")
	proto.RegisterType((*AddFederatedServerBitcoinAnchorKey)(nil), "eventmessages.AddFederatedServerBitcoinAnchorKey")
	proto.RegisterType((*AddFederatedServerSigningKey)(nil), "eventmessages.AddFederatedServerSigningKey")
	proto.RegisterType((*AddReplaceMatryoshkaHash)(nil), "eventmessages.AddReplaceMatryoshkaHash")
	proto.RegisterType((*CancelCoinbaseDescriptor)(nil), "eventmessages.CancelCoinbaseDescriptor")
	proto.RegisterType((*CoinbaseDescriptor)(nil), "eventmessages.CoinbaseDescriptor")
	proto.RegisterType((*DirectoryBlockSignatureEntry)(nil), "eventmessages.DirectoryBlockSignatureEntry")
	proto.RegisterType((*EndOfMinuteEntry)(nil), "eventmessages.EndOfMinuteEntry")
	proto.RegisterType((*ForwardCompatibleEntry)(nil), "eventmessages.ForwardCompatibleEntry")
	proto.RegisterType((*IncreaseServerCount)(nil), "eventmessages.IncreaseServerCount")
	proto.RegisterType((*RemoveFederatedServer)(nil), "eventmessages.RemoveFederatedServer")
	proto.RegisterType((*RevealMatryoshkaHash)(nil), "eventmessages.RevealMatryoshkaHash")
	proto.RegisterType((*ServerFault)(nil), "eventmessages.ServerFault")
}

func init() { proto.RegisterFile("eventmessages/adminBlock.proto", fileDescriptor_974412be9cb81647) }

var fileDescriptor_974412be9cb81647 = []byte{
	// 1197 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x6f, 0x6f, 0xdb, 0x44,
	0x18, 0xb7, 0xdb, 0xad, 0xd9, 0x9e, 0x34, 0x69, 0x77, 0xdd, 0x26, 0xab, 0x2a, 0x69, 0x30, 0xff,
	0x2a, 0xd0, 0x52, 0x31, 0x24, 0x18, 0x42, 0x4c, 0xb4, 0x4d, 0x37, 0x47, 0x30, 0x36, 0x5d, 0x27,
	0x24, 0x10, 0xd2, 0x74, 0xf1, 0x5d, 0x92, 0x53, 0x63, 0x3b, 0x3b, 0x9f, 0xc3, 0x02, 0x2f, 0x10,
	0xe2, 0x1b, 0xf0, 0x8a, 0x6f, 0xc3, 0x4b, 0x90, 0x78, 0xc3, 0x37, 0x60, 0x94, 0x2f, 0x82, 0x7c,
	0xb6, 0x9b, 0xd8, 0xbe, 0xa4, 0x15, 0xa5, 0xe2, 0x55, 0xe3, 0xc7, 0xbf, 0xe7, 0xf7, 0xbb, 0xbb,
	0xe7, 0xee, 0xf9, 0x9d, 0x0b, 0x0d, 0x36, 0x66, 0xbe, 0xf4, 0x58, 0x18, 0x92, 0x3e, 0x0b, 0x77,
	0x09, 0xf5, 0xb8, 0xbf, 0x3f, 0x0c, 0xdc, 0xe3, 0xd6, 0x48, 0x04, 0x32, 0x40, 0xb5, 0xdc, 0xfb,
	0xcd, 0xed, 0x3c, 0x3c, 0x1c, 0x10, 0xc1, 0xe8, 0xd3, 0xc9, 0x88, 0x85, 0x09, 0x7e, 0x73, 0xbb,
	0x1f, 0x04, 0xfd, 0x21, 0xdb, 0x55, 0x4f, 0xdd, 0xa8, 0xb7, 0x2b, 0xb9, 0xc7, 0x42, 0x49, 0xbc,
	0x51, 0x02, 0xb0, 0xbf, 0x07, 0xd8, 0x3b, 0x15, 0x41, 0x1f, 0xc0, 0xca, 0x80, 0x11, 0xca, 0x84,
	0x65, 0x36, 0xcd, 0x9d, 0xea, 0xdd, 0xed, 0x56, 0x4e, 0xa0, 0x35, 0x85, 0x3a, 0x0a, 0x86, 0x53,
	0x38, 0xba, 0x07, 0x15, 0xe6, 0x4b, 0xc1, 0x59, 0x68, 0x2d, 0x35, 0x97, 0x77, 0xaa, 0x77, 0x1b,
	0x73, 0x33, 0x0f, 0x7d, 0x29, 0x26, 0x38, 0x83, 0xdb, 0xdf, 0xc1, 0x7a, 0x91, 0x15, 0x1d, 0xc2,
	0xc6, 0x48, 0xb0, 0x31, 0x0f, 0xa2, 0x70, 0x9f, 0xb8, 0xc7, 0x98, 0xf5, 0x1c, 0x12, 0x0e, 0xd2,
	0x31, 0x6d, 0x14, 0x98, 0xe3, 0x57, 0x58, 0x87, 0x47, 0x4d, 0xa8, 0x76, 0x13, 0x56, 0xde, 0x1f,
	0x48, 0x6b, 0xa9, 0x69, 0xee, 0xd4, 0xf0, 0x6c, 0xc8, 0x7e, 0x59, 0x85, 0xb5, 0xc2, 0xc8, 0xd0,
	0x43, 0xa8, 0x13, 0x4a, 0xf7, 0x22, 0xca, 0xe5, 0x11, 0x13, 0xe3, 0xd3, 0xb5, 0x78, 0xa5, 0x34,
	0xa3, 0x59, 0x90, 0x63, 0xe0, 0x42, 0x1a, 0x6a, 0x43, 0x8d, 0x50, 0x7a, 0xd8, 0xeb, 0x71, 0x97,
	0x33, 0xdf, 0x9d, 0xa8, 0x01, 0x54, 0xef, 0x6e, 0x95, 0x79, 0xa6, 0x18, 0xc7, 0xc0, 0xf9, 0x24,
	0xf4, 0x04, 0x6e, 0x10, 0x4a, 0x1f, 0x10, 0x57, 0x06, 0x9c, 0xee, 0x51, 0x2a, 0x58, 0x18, 0x5a,
	0xcb, 0x8a, 0xa9, 0x59, 0x66, 0xca, 0xe3, 0x1c, 0x03, 0x97, 0x93, 0xd1, 0x11, 0xa0, 0x38, 0xc8,
	0x28, 0x13, 0x44, 0x32, 0x9a, 0x4e, 0xf2, 0x8a, 0xa2, 0x7c, 0x55, 0x43, 0x99, 0x07, 0x3a, 0x06,
	0xd6, 0xa4, 0xa3, 0x1f, 0x4d, 0xb0, 0xcb, 0xe1, 0x7d, 0x2e, 0xdd, 0x80, 0xfb, 0x7b, 0xbe, 0x3b,
	0x08, 0xc4, 0xa7, 0x6c, 0x62, 0x5d, 0x55, 0x2a, 0xef, 0x9e, 0xa9, 0x52, 0x4c, 0x74, 0x0c, 0x7c,
	0x0e, 0x7a, 0xf4, 0x1c, 0xb6, 0xca, 0xa8, 0x23, 0xde, 0xf7, 0xb9, 0xdf, 0x8f, 0xe5, 0x57, 0x94,
	0xfc, 0x3b, 0x67, 0xca, 0x4f, 0x53, 0x1c, 0x03, 0x2f, 0xa4, 0x44, 0x0c, 0x2c, 0x42, 0x29, 0x66,
	0xa3, 0x21, 0x71, 0xd9, 0x23, 0x22, 0xc5, 0x24, 0x08, 0x07, 0xc7, 0x44, 0x6d, 0xd8, 0x8a, 0x92,
	0x7b, 0xab, 0x2c, 0xa7, 0x85, 0x3b, 0x06, 0x9e, 0x4b, 0x15, 0xcb, 0xb8, 0xc4, 0x77, 0xd9, 0xf0,
	0x20, 0xe0, 0x7e, 0x97, 0x84, 0xac, 0xcd, 0x42, 0x57, 0xf0, 0x91, 0x0c, 0x84, 0x75, 0x4d, 0x2b,
	0x73, 0x30, 0x07, 0x1e, 0xcb, 0xcc, 0xa3, 0x8a, 0xf7, 0x86, 0x5b, 0x16, 0xb8, 0xae, 0xdd, 0x1b,
	0x5a, 0x6a, 0x4d, 0x7a, 0x5c, 0x15, 0xca, 0x05, 0x73, 0x65, 0x20, 0x26, 0xea, 0xa0, 0xc5, 0xcb,
	0x47, 0x64, 0x24, 0x98, 0x3a, 0x71, 0x16, 0x68, 0xab, 0xd2, 0x5e, 0x90, 0x12, 0x57, 0x65, 0x11,
	0x25, 0x7a, 0x04, 0xeb, 0xcc, 0xa7, 0x8f, 0x7b, 0x8f, 0xb8, 0x1f, 0xc9, 0x54, 0xa6, 0xaa, 0x6d,
	0x69, 0x87, 0x05, 0x98, 0x63, 0xe0, 0x52, 0x2a, 0x7a, 0x06, 0xb7, 0x7b, 0x81, 0xf8, 0x86, 0x08,
	0x7a, 0x10, 0x78, 0x23, 0x22, 0x79, 0x77, 0x98, 0x92, 0xae, 0x2a, 0xd2, 0x37, 0x0a, 0xa4, 0x0f,
	0xb4, 0x60, 0xc7, 0xc0, 0x73, 0x68, 0xd0, 0x17, 0xb0, 0xc1, 0x7d, 0x57, 0x30, 0x12, 0xb2, 0x64,
	0x87, 0x1d, 0x04, 0x91, 0x2f, 0xad, 0x9a, 0x62, 0xb7, 0x0b, 0xec, 0x9d, 0x32, 0xd2, 0x31, 0xb0,
	0x8e, 0x00, 0x7d, 0x0d, 0xb7, 0x04, 0xf3, 0x82, 0x31, 0x2b, 0x1e, 0xf7, 0xba, 0x62, 0x7e, 0xbd,
	0xc0, 0x8c, 0x75, 0x58, 0xc7, 0xc0, 0x7a, 0x12, 0xf4, 0x25, 0xdc, 0x14, 0x6c, 0xcc, 0xc8, 0xb0,
	0xb0, 0xef, 0xd7, 0x14, 0xf9, 0x6b, 0x25, 0xf2, 0x32, 0xd4, 0x31, 0xb0, 0x96, 0x02, 0xdd, 0x87,
	0x6a, 0xa8, 0x44, 0x1e, 0x90, 0x68, 0x28, 0xad, 0x75, 0xc5, 0xb8, 0x59, 0x60, 0x3c, 0x9a, 0x22,
	0x1c, 0x03, 0xcf, 0x26, 0xec, 0x57, 0xe0, 0xea, 0x98, 0x0c, 0x23, 0x66, 0x3f, 0x87, 0x7a, 0xbe,
	0x53, 0xa3, 0x8f, 0x61, 0x8d, 0x53, 0xe6, 0x4b, 0x2e, 0x27, 0x07, 0x03, 0xc2, 0xfd, 0x4e, 0x7b,
	0x91, 0xb3, 0x14, 0xb1, 0xe7, 0x70, 0x15, 0x1f, 0x6a, 0xb9, 0xa6, 0x7e, 0x51, 0xc5, 0x06, 0x00,
	0xcb, 0xbb, 0x48, 0x0d, 0xcf, 0x44, 0xec, 0x1f, 0x4c, 0xb8, 0x51, 0xea, 0xfd, 0x17, 0x15, 0xbd,
	0x03, 0x15, 0x92, 0xba, 0xcd, 0xd2, 0xfc, 0xb4, 0x0c, 0x63, 0x47, 0x80, 0xca, 0x6d, 0xf4, 0xf2,
	0x97, 0xfa, 0x57, 0x13, 0xec, 0xb3, 0xdd, 0xe3, 0x3f, 0x18, 0xc7, 0x31, 0x9b, 0x3c, 0x11, 0x3c,
	0x10, 0x5c, 0x66, 0x15, 0x98, 0x0d, 0x21, 0x0b, 0x2a, 0xc7, 0x6c, 0x12, 0xdf, 0xbc, 0x94, 0x37,
	0xd7, 0x70, 0xf6, 0x88, 0xde, 0x84, 0x3a, 0x73, 0x69, 0x48, 0x9e, 0x44, 0xdd, 0x21, 0x77, 0x63,
	0x13, 0x8a, 0x9d, 0x76, 0x15, 0x17, 0xa2, 0xf6, 0x2f, 0x26, 0x6c, 0x2d, 0x32, 0xa2, 0xcb, 0x9f,
	0xc3, 0x16, 0x5c, 0x1f, 0x9d, 0x0e, 0x72, 0x59, 0x0d, 0x72, 0x1a, 0x28, 0xd6, 0xe2, 0x4a, 0xb9,
	0x16, 0x7f, 0x99, 0x60, 0xcd, 0xf3, 0xb6, 0x8b, 0x8e, 0xfe, 0x23, 0xa8, 0x7b, 0xf9, 0x1e, 0xb3,
	0x60, 0x53, 0x16, 0xa0, 0xa8, 0x03, 0xf5, 0x5e, 0x72, 0x36, 0x1e, 0x47, 0x72, 0x14, 0xc9, 0xf8,
	0xfe, 0xb4, 0xac, 0x31, 0xb4, 0xa7, 0x82, 0xf8, 0x21, 0x71, 0x25, 0x0f, 0xfc, 0xf4, 0x10, 0xe1,
	0x42, 0xa2, 0x3d, 0x02, 0x6b, 0x9e, 0xaf, 0xa2, 0xb7, 0x61, 0x9d, 0x4e, 0xad, 0x30, 0x59, 0x26,
	0x53, 0x2d, 0x53, 0x29, 0x8e, 0x76, 0x60, 0x6d, 0x1a, 0xeb, 0xf8, 0x94, 0xbd, 0x48, 0x2b, 0x52,
	0x0c, 0xdb, 0xcf, 0x00, 0x69, 0xb4, 0xca, 0x53, 0x32, 0xff, 0xed, 0x94, 0x7e, 0x37, 0x61, 0x6b,
	0x91, 0xd7, 0xa2, 0x87, 0x70, 0x33, 0x2b, 0x87, 0xba, 0x2b, 0x9f, 0xa3, 0x7e, 0xda, 0x04, 0xd4,
	0x85, 0xed, 0xec, 0x9a, 0x3e, 0x47, 0x30, 0xad, 0xaa, 0x55, 0xec, 0xf3, 0xd9, 0x7b, 0x7c, 0x16,
	0x81, 0xfd, 0x3e, 0xac, 0x17, 0x1d, 0x1d, 0xd9, 0xb0, 0xea, 0xa9, 0xc7, 0xcf, 0x23, 0xaf, 0x9b,
	0xde, 0xe7, 0x6b, 0x38, 0x17, 0xb3, 0x3f, 0x81, 0xdb, 0x7a, 0xd3, 0x46, 0x08, 0xae, 0x84, 0xfc,
	0x5b, 0x96, 0x66, 0xa9, 0xdf, 0x71, 0x8c, 0x12, 0x49, 0xd4, 0x70, 0x57, 0xb1, 0xfa, 0x6d, 0xdf,
	0x81, 0x0d, 0x8d, 0x31, 0xa3, 0xdb, 0xb0, 0x42, 0x3c, 0x65, 0xe6, 0x09, 0x41, 0xfa, 0x64, 0xbf,
	0x80, 0x5b, 0x5a, 0xb7, 0xbd, 0xfc, 0x9e, 0xf9, 0x93, 0x09, 0x37, 0x75, 0x5e, 0xfc, 0x7f, 0x9e,
	0x51, 0xfb, 0xcf, 0x25, 0xa8, 0xce, 0xd8, 0x39, 0xba, 0x07, 0xd7, 0x4f, 0x3f, 0x55, 0xd3, 0x51,
	0x6c, 0xb6, 0x92, 0x8f, 0xd9, 0x56, 0xf6, 0x31, 0xdb, 0x7a, 0x9a, 0x21, 0xf0, 0x14, 0x8c, 0x76,
	0xe1, 0x5a, 0x72, 0x11, 0xe8, 0xb4, 0x17, 0x0d, 0xe0, 0x14, 0x84, 0x3e, 0x84, 0x1a, 0x99, 0x5e,
	0x0f, 0x3a, 0xed, 0xf4, 0xeb, 0x4a, 0x9b, 0x95, 0x47, 0xc6, 0x6d, 0x7f, 0xec, 0x25, 0xc7, 0x37,
	0x69, 0x88, 0xd9, 0x63, 0xb1, 0x0c, 0x57, 0x4b, 0x65, 0x40, 0x2d, 0x40, 0x29, 0x77, 0x72, 0x39,
	0x4c, 0x80, 0x2b, 0x0a, 0xa8, 0x79, 0x83, 0xee, 0x43, 0x2d, 0xcc, 0xb6, 0xf9, 0x67, 0x3c, 0x94,
	0x56, 0x45, 0x9d, 0xf8, 0xf9, 0x67, 0x25, 0x0f, 0xdf, 0xdf, 0xfb, 0xed, 0xa4, 0x61, 0xfe, 0x71,
	0xd2, 0x30, 0x5f, 0x9e, 0x34, 0xcc, 0x9f, 0xff, 0x6e, 0x18, 0xd0, 0x74, 0x03, 0xaf, 0xa5, 0xba,
	0x41, 0xf6, 0x87, 0xe6, 0xc9, 0xbe, 0xca, 0xff, 0xbb, 0xa1, 0xbb, 0xa2, 0x56, 0xfe, 0xbd, 0x7f,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x61, 0xbf, 0x6d, 0x50, 0xa6, 0x10, 0x00, 0x00,
}

func (m *AdminBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.Header.Size()))
		n1, err1 := m.Header.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdminBlock(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdminBlockHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminBlockHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PreviousBackRefHash != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.PreviousBackRefHash.Size()))
		n2, err2 := m.PreviousBackRefHash.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.BlockHeight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdminBlockEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminBlockEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn3, err3 := m.Value.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += nn3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdminBlockEntry_AddAuditServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddAuditServer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AddAuditServer.Size()))
		n4, err4 := m.AddAuditServer.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}
func (m *AdminBlockEntry_AddEfficiency) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddEfficiency != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AddEfficiency.Size()))
		n5, err5 := m.AddEfficiency.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}
func (m *AdminBlockEntry_AddFactoidAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddFactoidAddress != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AddFactoidAddress.Size()))
		n6, err6 := m.AddFactoidAddress.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}
func (m *AdminBlockEntry_AddFederatedServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddFederatedServer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AddFederatedServer.Size()))
		n7, err7 := m.AddFederatedServer.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	return i, nil
}
func (m *AdminBlockEntry_AddFederatedServerBitcoinAnchorKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddFederatedServerBitcoinAnchorKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AddFederatedServerBitcoinAnchorKey.Size()))
		n8, err8 := m.AddFederatedServerBitcoinAnchorKey.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}
func (m *AdminBlockEntry_AddFederatedServerSigningKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddFederatedServerSigningKey != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AddFederatedServerSigningKey.Size()))
		n9, err9 := m.AddFederatedServerSigningKey.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	return i, nil
}
func (m *AdminBlockEntry_AddReplaceMatryoshkaHash) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddReplaceMatryoshkaHash != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AddReplaceMatryoshkaHash.Size()))
		n10, err10 := m.AddReplaceMatryoshkaHash.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}
func (m *AdminBlockEntry_CancelCoinbaseDescriptor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CancelCoinbaseDescriptor != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.CancelCoinbaseDescriptor.Size()))
		n11, err11 := m.CancelCoinbaseDescriptor.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	return i, nil
}
func (m *AdminBlockEntry_CoinbaseDescriptor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CoinbaseDescriptor != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.CoinbaseDescriptor.Size()))
		n12, err12 := m.CoinbaseDescriptor.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	return i, nil
}
func (m *AdminBlockEntry_DirectoryBlockSignatureEntry) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DirectoryBlockSignatureEntry != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.DirectoryBlockSignatureEntry.Size()))
		n13, err13 := m.DirectoryBlockSignatureEntry.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	return i, nil
}
func (m *AdminBlockEntry_EndOfMinuteEntry) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EndOfMinuteEntry != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.EndOfMinuteEntry.Size()))
		n14, err14 := m.EndOfMinuteEntry.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	return i, nil
}
func (m *AdminBlockEntry_ForwardCompatibleEntry) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ForwardCompatibleEntry != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.ForwardCompatibleEntry.Size()))
		n15, err15 := m.ForwardCompatibleEntry.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	return i, nil
}
func (m *AdminBlockEntry_IncreaseServerCount) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IncreaseServerCount != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IncreaseServerCount.Size()))
		n16, err16 := m.IncreaseServerCount.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	return i, nil
}
func (m *AdminBlockEntry_RemoveFederatedServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RemoveFederatedServer != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.RemoveFederatedServer.Size()))
		n17, err17 := m.RemoveFederatedServer.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	return i, nil
}
func (m *AdminBlockEntry_RevealMatryoshkaHash) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RevealMatryoshkaHash != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.RevealMatryoshkaHash.Size()))
		n18, err18 := m.RevealMatryoshkaHash.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	return i, nil
}
func (m *AdminBlockEntry_ServerFault) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerFault != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.ServerFault.Size()))
		n19, err19 := m.ServerFault.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	return i, nil
}
func (m *AddAuditServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddAuditServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n20, err20 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.BlockHeight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddEfficiency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddEfficiency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n21, err21 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.Efficiency != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.Efficiency))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddFactoidAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFactoidAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n22, err22 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	if m.Address != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.Address.Size()))
		n23, err23 := m.Address.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddFederatedServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFederatedServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n24, err24 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	if m.BlockHeight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddFederatedServerBitcoinAnchorKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFederatedServerBitcoinAnchorKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n25, err25 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += n25
	}
	if m.KeyPriority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.KeyPriority))
	}
	if m.KeyType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.KeyType))
	}
	if len(m.EcdsaPublicKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(len(m.EcdsaPublicKey)))
		i += copy(dAtA[i:], m.EcdsaPublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddFederatedServerSigningKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFederatedServerSigningKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n26, err26 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += n26
	}
	if m.KeyPriority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.KeyPriority))
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.BlockHeight != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddReplaceMatryoshkaHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddReplaceMatryoshkaHash) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n27, err27 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	if m.MatryoshkaHash != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.MatryoshkaHash.Size()))
		n28, err28 := m.MatryoshkaHash.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	if len(m.FactoidOutputs) > 0 {
		for _, msg := range m.FactoidOutputs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAdminBlock(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CancelCoinbaseDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelCoinbaseDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DescriptorHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.DescriptorHeight))
	}
	if m.DescriptorIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.DescriptorIndex))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CoinbaseDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinbaseDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FactoidOutputs) > 0 {
		for _, msg := range m.FactoidOutputs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminBlock(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DirectoryBlockSignatureEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectoryBlockSignatureEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityAdminChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityAdminChainID.Size()))
		n29, err29 := m.IdentityAdminChainID.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.PreviousDirectoryBlockSignature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.PreviousDirectoryBlockSignature.Size()))
		n30, err30 := m.PreviousDirectoryBlockSignature.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EndOfMinuteEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndOfMinuteEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinuteNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.MinuteNumber))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ForwardCompatibleEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardCompatibleEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.Size_))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IncreaseServerCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncreaseServerCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.Amount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveFederatedServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveFederatedServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n31, err31 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err31 != nil {
			return 0, err31
		}
		i += n31
	}
	if m.BlockHeight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RevealMatryoshkaHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevealMatryoshkaHash) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdentityChainID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.IdentityChainID.Size()))
		n32, err32 := m.IdentityChainID.MarshalTo(dAtA[i:])
		if err32 != nil {
			return 0, err32
		}
		i += n32
	}
	if m.MatryoshkaHash != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.MatryoshkaHash.Size()))
		n33, err33 := m.MatryoshkaHash.MarshalTo(dAtA[i:])
		if err33 != nil {
			return 0, err33
		}
		i += n33
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerFault) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerFault) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.Timestamp.Size()))
		n34, err34 := m.Timestamp.MarshalTo(dAtA[i:])
		if err34 != nil {
			return 0, err34
		}
		i += n34
	}
	if m.ServerID != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.ServerID.Size()))
		n35, err35 := m.ServerID.MarshalTo(dAtA[i:])
		if err35 != nil {
			return 0, err35
		}
		i += n35
	}
	if m.AuditServerID != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.AuditServerID.Size()))
		n36, err36 := m.AuditServerID.MarshalTo(dAtA[i:])
		if err36 != nil {
			return 0, err36
		}
		i += n36
	}
	if m.VmIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.VmIndex))
	}
	if m.BlockHeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.BlockHeight))
	}
	if m.MessageEntryHeight != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAdminBlock(dAtA, i, uint64(m.MessageEntryHeight))
	}
	if len(m.SignatureList) > 0 {
		for _, msg := range m.SignatureList {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintAdminBlock(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAdminBlock(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AdminBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovAdminBlock(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminBlockHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreviousBackRefHash != nil {
		l = m.PreviousBackRefHash.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminBlockEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminBlockEntry_AddAuditServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddAuditServer != nil {
		l = m.AddAuditServer.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_AddEfficiency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddEfficiency != nil {
		l = m.AddEfficiency.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_AddFactoidAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFactoidAddress != nil {
		l = m.AddFactoidAddress.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_AddFederatedServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFederatedServer != nil {
		l = m.AddFederatedServer.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_AddFederatedServerBitcoinAnchorKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFederatedServerBitcoinAnchorKey != nil {
		l = m.AddFederatedServerBitcoinAnchorKey.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_AddFederatedServerSigningKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFederatedServerSigningKey != nil {
		l = m.AddFederatedServerSigningKey.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_AddReplaceMatryoshkaHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddReplaceMatryoshkaHash != nil {
		l = m.AddReplaceMatryoshkaHash.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_CancelCoinbaseDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelCoinbaseDescriptor != nil {
		l = m.CancelCoinbaseDescriptor.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_CoinbaseDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CoinbaseDescriptor != nil {
		l = m.CoinbaseDescriptor.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_DirectoryBlockSignatureEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DirectoryBlockSignatureEntry != nil {
		l = m.DirectoryBlockSignatureEntry.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_EndOfMinuteEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndOfMinuteEntry != nil {
		l = m.EndOfMinuteEntry.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_ForwardCompatibleEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwardCompatibleEntry != nil {
		l = m.ForwardCompatibleEntry.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_IncreaseServerCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IncreaseServerCount != nil {
		l = m.IncreaseServerCount.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_RemoveFederatedServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveFederatedServer != nil {
		l = m.RemoveFederatedServer.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_RevealMatryoshkaHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevealMatryoshkaHash != nil {
		l = m.RevealMatryoshkaHash.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AdminBlockEntry_ServerFault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerFault != nil {
		l = m.ServerFault.Size()
		n += 2 + l + sovAdminBlock(uint64(l))
	}
	return n
}
func (m *AddAuditServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddEfficiency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.Efficiency != 0 {
		n += 1 + sovAdminBlock(uint64(m.Efficiency))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFactoidAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFederatedServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFederatedServerBitcoinAnchorKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.KeyPriority != 0 {
		n += 1 + sovAdminBlock(uint64(m.KeyPriority))
	}
	if m.KeyType != 0 {
		n += 1 + sovAdminBlock(uint64(m.KeyType))
	}
	l = len(m.EcdsaPublicKey)
	if l > 0 {
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFederatedServerSigningKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.KeyPriority != 0 {
		n += 1 + sovAdminBlock(uint64(m.KeyPriority))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddReplaceMatryoshkaHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.MatryoshkaHash != nil {
		l = m.MatryoshkaHash.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if len(m.FactoidOutputs) > 0 {
		for _, e := range m.FactoidOutputs {
			l = e.Size()
			n += 1 + l + sovAdminBlock(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelCoinbaseDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.DescriptorHeight))
	}
	if m.DescriptorIndex != 0 {
		n += 1 + sovAdminBlock(uint64(m.DescriptorIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CoinbaseDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FactoidOutputs) > 0 {
		for _, e := range m.FactoidOutputs {
			l = e.Size()
			n += 1 + l + sovAdminBlock(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DirectoryBlockSignatureEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityAdminChainID != nil {
		l = m.IdentityAdminChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.PreviousDirectoryBlockSignature != nil {
		l = m.PreviousDirectoryBlockSignature.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EndOfMinuteEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinuteNumber != 0 {
		n += 1 + sovAdminBlock(uint64(m.MinuteNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForwardCompatibleEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovAdminBlock(uint64(m.Size_))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IncreaseServerCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovAdminBlock(uint64(m.Amount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveFederatedServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.BlockHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RevealMatryoshkaHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityChainID != nil {
		l = m.IdentityChainID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.MatryoshkaHash != nil {
		l = m.MatryoshkaHash.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerFault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.ServerID != nil {
		l = m.ServerID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.AuditServerID != nil {
		l = m.AuditServerID.Size()
		n += 1 + l + sovAdminBlock(uint64(l))
	}
	if m.VmIndex != 0 {
		n += 1 + sovAdminBlock(uint64(m.VmIndex))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.BlockHeight))
	}
	if m.MessageEntryHeight != 0 {
		n += 1 + sovAdminBlock(uint64(m.MessageEntryHeight))
	}
	if len(m.SignatureList) > 0 {
		for _, e := range m.SignatureList {
			l = e.Size()
			n += 1 + l + sovAdminBlock(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAdminBlock(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAdminBlock(x uint64) (n int) {
	return sovAdminBlock(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AdminBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &AdminBlockHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &AdminBlockEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminBlockHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminBlockHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminBlockHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBackRefHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousBackRefHash == nil {
				m.PreviousBackRefHash = &Hash{}
			}
			if err := m.PreviousBackRefHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminBlockEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminBlockEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminBlockEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAuditServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddAuditServer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_AddAuditServer{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddEfficiency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddEfficiency{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_AddEfficiency{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFactoidAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddFactoidAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_AddFactoidAddress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFederatedServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddFederatedServer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_AddFederatedServer{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFederatedServerBitcoinAnchorKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddFederatedServerBitcoinAnchorKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_AddFederatedServerBitcoinAnchorKey{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFederatedServerSigningKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddFederatedServerSigningKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_AddFederatedServerSigningKey{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddReplaceMatryoshkaHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddReplaceMatryoshkaHash{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_AddReplaceMatryoshkaHash{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelCoinbaseDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CancelCoinbaseDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_CancelCoinbaseDescriptor{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinbaseDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CoinbaseDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_CoinbaseDescriptor{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryBlockSignatureEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DirectoryBlockSignatureEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_DirectoryBlockSignatureEntry{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOfMinuteEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndOfMinuteEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_EndOfMinuteEntry{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardCompatibleEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForwardCompatibleEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_ForwardCompatibleEntry{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncreaseServerCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IncreaseServerCount{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_IncreaseServerCount{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveFederatedServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveFederatedServer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_RemoveFederatedServer{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealMatryoshkaHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RevealMatryoshkaHash{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_RevealMatryoshkaHash{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerFault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServerFault{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AdminBlockEntry_ServerFault{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddAuditServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddAuditServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddAuditServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddEfficiency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddEfficiency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddEfficiency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Efficiency", wireType)
			}
			m.Efficiency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Efficiency |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFactoidAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFactoidAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFactoidAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Hash{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFederatedServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFederatedServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFederatedServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFederatedServerBitcoinAnchorKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFederatedServerBitcoinAnchorKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFederatedServerBitcoinAnchorKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPriority", wireType)
			}
			m.KeyPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcdsaPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EcdsaPublicKey = append(m.EcdsaPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EcdsaPublicKey == nil {
				m.EcdsaPublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFederatedServerSigningKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFederatedServerSigningKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFederatedServerSigningKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPriority", wireType)
			}
			m.KeyPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddReplaceMatryoshkaHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddReplaceMatryoshkaHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddReplaceMatryoshkaHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatryoshkaHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatryoshkaHash == nil {
				m.MatryoshkaHash = &Hash{}
			}
			if err := m.MatryoshkaHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactoidOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactoidOutputs = append(m.FactoidOutputs, &TransactionAddress{})
			if err := m.FactoidOutputs[len(m.FactoidOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelCoinbaseDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelCoinbaseDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelCoinbaseDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorHeight", wireType)
			}
			m.DescriptorHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorIndex", wireType)
			}
			m.DescriptorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinbaseDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinbaseDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinbaseDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactoidOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactoidOutputs = append(m.FactoidOutputs, &TransactionAddress{})
			if err := m.FactoidOutputs[len(m.FactoidOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectoryBlockSignatureEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectoryBlockSignatureEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectoryBlockSignatureEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityAdminChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityAdminChainID == nil {
				m.IdentityAdminChainID = &Hash{}
			}
			if err := m.IdentityAdminChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousDirectoryBlockSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousDirectoryBlockSignature == nil {
				m.PreviousDirectoryBlockSignature = &Signature{}
			}
			if err := m.PreviousDirectoryBlockSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndOfMinuteEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndOfMinuteEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndOfMinuteEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinuteNumber", wireType)
			}
			m.MinuteNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinuteNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardCompatibleEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardCompatibleEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardCompatibleEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncreaseServerCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncreaseServerCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncreaseServerCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveFederatedServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveFederatedServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveFederatedServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevealMatryoshkaHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevealMatryoshkaHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevealMatryoshkaHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityChainID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityChainID == nil {
				m.IdentityChainID = &Hash{}
			}
			if err := m.IdentityChainID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatryoshkaHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatryoshkaHash == nil {
				m.MatryoshkaHash = &Hash{}
			}
			if err := m.MatryoshkaHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerFault) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerFault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerFault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerID == nil {
				m.ServerID = &Hash{}
			}
			if err := m.ServerID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditServerID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuditServerID == nil {
				m.AuditServerID = &Hash{}
			}
			if err := m.AuditServerID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmIndex", wireType)
			}
			m.VmIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageEntryHeight", wireType)
			}
			m.MessageEntryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageEntryHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignatureList = append(m.SignatureList, &Signature{})
			if err := m.SignatureList[len(m.SignatureList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdminBlock(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdminBlock
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdminBlock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdminBlock
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAdminBlock
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdminBlock
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdminBlock(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAdminBlock
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdminBlock = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdminBlock   = fmt.Errorf("proto: integer overflow")
)
